# 의존성 Dependency

## 의존성이란?
종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 또한 변해야 된다는 것을 의미한다.  
 
상위 모듈은 하위 모듈에 대한 의존성이 떨어지게 되는 경우 == '디커플링이 된다.'  

```swift
import UIKit

// 의존성
class 트레이너 {
    let 이름: String
    // *1
    let 마이포켓몬: 포켓몬

    init(이름: String) {
        self.이름 = 이름
        self.마이포켓몬 = 포켓몬(이름: "피카츄")
    }
}

class 포켓몬 {
    let 이름: String

    init(이름: String) {
        self.이름 = 이름
    }

    func 공격() {
        print(이름, "!! 몸통박치기 !!!! ")
    }
}

let 한지우 = 트레이너(이름: "한지우")
한지우.마이포켓몬.공격() // 피카츄 !! 몸통박치기 !!!!

// 지우는 피카츄에 의존성을 띈다.  *1
/*
 지우 : "피카츄들어가 망나뇽나와!"
 피카츄를 망나뇽으로 바꾸려면 객체를 수정해야한다.  *1
 변경에 자유롭지 못하다. 
 */
```


## 의존성 주입 (DI, Dependency Injection)

```swift
import UIKit

// DI
class 트레이너 {
    let 이름: String
    let 포켓몬: 포켓몬

    init(이름: String, 포켓몬: 포켓몬) {
        self.이름 = 이름
        self.포켓몬 = 포켓몬
    }
}

class 포켓몬 {
    let 이름: String

    init(이름: String) {
        self.이름 = 이름
    }

    func 공격() {
        print(이름, "!! 몸통박치기 !!!! ")
    }
}

let 한지우 = 트레이너(이름: "한지우", 포켓몬: 포켓몬(이름: "망나뇽"))
// 클래스 내부가 아닌 외부에서 제어함. 
한지우.포켓몬.공격() // 망나뇽 !! 몸통박치기 !!!!

```

## 의존성 주입의 장점
모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅 하기 쉽고 마이그레이션 하기도 수월하다  
구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 조금 더 명확해 진다. 

## 의존성 주입의 단점
모듈들이 더욱더 분리 되므로 클래스 수가 늘어나 복잡성이 증가 될 수 있다.  
약간의 런타임 패널티가 생기기도함  

## 의존성 주입의 원칙
"상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다."  
"둘다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 한다."  


## 제어의 역전 (IoC, )
응집도를 높이고 결합도를 낮춰 유연한 코드가 될 수 있도록 코드를 작성한다. 

## 참조
