# 팩토리 패턴 Factory Pattern
객체 생성 부분을 때어내 추상화한 패턴

상속관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정, 하위 클래스에서 객체 새엇ㅇ에 관한 구체적인 내용을 결정  

상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결함을 가짐  
상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 가짐  
객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩터링 하더라도 한 곳만 고치면되니 유지보수성 증가  


## swift로 팩토리 패턴 만들어보기

```swift
import UIKit

// Factory Pattern

protocol 커피 {
    var 가격: Int { get }

    func 이것은()
}

class 그냥커피클래스: 커피 {
    var 가격: Int = 2000

    func 이것은() {
        print("이것은 라떼입니다. 가격은 : ", 가격)
    }
}

class 라떼클래스: 커피 {
    let 가격: Int

    init(_ 가격: Int){
        self.가격 = 가격
    }

    func 이것은() {
        print("이것은 라떼입니다. 가격은 : ", 가격)
    }
}

class 아이스아메리카노클래스: 커피 {
    let 가격: Int

    init(_ 가격: Int){
        self.가격 = 가격
    }

    func 이것은() {
        print("이것은 아이스아메리카노입니다. 가격은 : ", 가격)
    }
}


class 바리스타공장 {
    // 문자열 비교기반이 아닌 enum이나 map을 이용하여 매핑할 수 도 있음.
    func get커피(커피이름: String, 가격: Int) -> 커피 {
        if 커피이름 == "라떼" {
            return 라떼클래스(가격)
        } else if 커피이름 == "아이스아메리카노" {
            return 아이스아메리카노클래스(가격)
        } else {
            return 그냥커피클래스()
        }
    }
}

let 라떼 = 바리스타공장().get커피(커피이름: "라떼", 가격: 4000)
let 아아 = 바리스타공장().get커피(커피이름: "아이스아메리카노", 가격: 3000)
라떼.이것은() // 이것은 라떼입니다. 가격은 :  4000
아아.이것은() // 이것은 아이스아메리카노입니다. 가격은 :  3000

/*
 상위클래스인 '바리스타공장'이 중요한 뼈대를 결정하고
 하위클래스인 '라떼클래스', '아이스아메리카노클래스'가 구체적인 내용을 결정하고 잇습니다.
 이는 의존성 주입이라고도 볼 수 있다.(?)
 */
 
```



## 참조

[면접을 위한 CS 전공지식 노트 주홍철 저](https://github.com/gyoogle/tech-interview-for-developer)  
[야곰닷넷 디자인패턴](https://yagom.net/courses/design-pattern-in-swift/)
